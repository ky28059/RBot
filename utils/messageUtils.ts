import {
    CommandInteraction, Message, MessageEmbed,
    MessageActionRow, MessageButton, MessageSelectMenu, MessageComponentInteraction, MessageOptions,
} from 'discord.js';
import {err} from './messages';


// Replies to a message or interaction.
// TODO: `options.flags` are incompatible between messages and command interactions;
// is there any fix beyond disallowing this property?
export async function reply(target: Message | CommandInteraction, content: string | Omit<MessageOptions, 'flags'>) {
    return target instanceof CommandInteraction
        ? target.reply({...(typeof content === 'string' ? {content} : content), fetchReply: true})
        : target.channel.send(content);
}

// Replies to a message or interaction with the specified embed.
export async function replyEmbed(target: Message | CommandInteraction, embed: MessageEmbed) {
    return reply(target, {embeds: [embed]})
}

// Returns the author of a message or interaction.
export function author(target: Message | CommandInteraction) {
    return target instanceof CommandInteraction ? target.user : target.author;
}

// Slices a string down to a set length.
export function truncate(string: string, len: number) {
    if (string.length <= len) return string;

    const diff = len - string.length;
    // 24 is the length of truncateMessage without ${truncated}
    const truncated = diff + 24 + String(diff + 24).length;
    const truncateMessage = `\n[Truncated ${truncated} characters]`;

    return string.slice(0, len - truncated) + truncateMessage;
}

// Sends a multi-embed, paginated message.
export async function pagedMessage(target: Message | CommandInteraction, pages: MessageEmbed[]) {
    if (!pages.length) return;
    if (pages.length === 1) return reply(target, {embeds: [pages[0]]});

    let index = 0;
    const buttonRow = new MessageActionRow()
        .addComponents(
            new MessageButton()
                .setCustomId('first')
                .setLabel('⏮️')
                .setStyle('SECONDARY'),
            new MessageButton()
                .setCustomId('previous')
                .setLabel('◀️')
                .setStyle('SECONDARY'),
            /* Maybe a select menu that let you choose pages would be nice
            new MessageSelectMenu()
                .setCustomId('select')
                .setPlaceholder('Nothing selected')
                .addOptions([
                    {
                        label: 'Select me',
                        description: 'This is a description',
                        value: 'first_option',
                    },
                    {
                        label: 'You can select me too',
                        description: 'This is also a description',
                        value: 'second_option',
                    },
                ]),
            */
            new MessageButton()
                .setCustomId('counter')
                .setLabel(String(index + 1))
                .setDisabled(true)
                .setStyle('SECONDARY'),
            new MessageButton()
                .setCustomId('next')
                .setLabel('▶️')
                .setStyle('SECONDARY'),
            new MessageButton()
                .setCustomId('last')
                .setLabel('⏭️')
                .setStyle('SECONDARY'),
        );

    const pagedMessage = await reply(target, {embeds: [pages[0]], components: [buttonRow]});
    if (!('createMessageComponentCollector' in pagedMessage)) return;

    const authorID = author(target).id;
    const collector = pagedMessage.createMessageComponentCollector({time: 30000});

    collector.on('collect', i => {
        // If the interaction was not generated by the original message author, inform them they are not allowed to switch pages
        if (i.user.id !== authorID)
            return i.reply({embeds: [err('PAGINATION_ERROR', 'Non-author users are not allowed to switch pages on commands they didn\'t send')], ephemeral: true});

        // Defer component loading to prevent "This interaction failed"
        i.deferUpdate();

        switch (i.customId) {
            case 'first':
                index = 0;
                break;
            case 'previous':
                index = index === 0 ? pages.length - 1 : index - 1;
                break;
            case 'next':
                index = (index + 1) % pages.length;
                break;
            case 'last':
                index = pages.length - 1;
                break;
        }
        (buttonRow.components.find(x => x.customId === 'counter') as MessageButton).setLabel(String(index + 1));
        pagedMessage.edit({embeds: [pages[index]], components: [buttonRow]});
    });

    // Disable all buttons on timeout
    collector.on('end', () => {
        buttonRow.components.forEach(x => x.setDisabled(true));
        pagedMessage.edit({embeds: [pages[index]], components: [buttonRow]});
    });
}
